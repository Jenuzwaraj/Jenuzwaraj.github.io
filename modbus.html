<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Modbus Protocol — Complete Tutorial & Reference</title>
  
  <style>
    :root{
      --bg1:#f8fbfd;
      --bg2:#e9f5f7;
      --card:#ffffff;
      --navy:#293462;
      --muted:#0e4d66;
      --text:#122;
      --code-bg:#f4fbfd;
      --code-text:#073;
      --teal:#1cd6ce;
      --shadow:rgba(16,24,40,0.06);
      --header-grad:linear-gradient(90deg,#b3ecff,#a8fff0,#d9ffff);
      --header-text:#083c5d;
    }

    html,body{
      height:100%;
      margin:0;
      font-family:'Segoe UI',Tahoma,Verdana,sans-serif;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* HEADER */
    header{
      background:var(--header-grad);
      padding:48px 20px 60px;
      position:relative;
      text-align:center;
      box-shadow:0 3px 16px var(--shadow);
    }
    header h1{
      margin:0;
      font-size:2.1rem;
      font-weight:700;
      color:var(--header-text);
    }

    /* HAMBURGER - larger tap area for mobile */
    .hamburger {
      position:absolute;
      right:14px;
      bottom:14px;
      width:44px;           /* larger area for touch */
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:1200;
      background:transparent;
      border-radius:8px;
    }
    .hamburger-inner{
      width:28px;
      height:22px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      padding:4px 0;
      box-sizing:border-box;
    }
    .hamburger-inner span{
      display:block;
      height:3px;
      background:var(--header-text);
      border-radius:4px;
      transition:transform .25s ease,opacity .2s ease,background .15s;
    }
    .hamburger[aria-expanded="true"] .hamburger-inner span:nth-child(1){ transform: translateY(8px) rotate(45deg); }
    .hamburger[aria-expanded="true"] .hamburger-inner span:nth-child(2){ opacity:0; }
    .hamburger[aria-expanded="true"] .hamburger-inner span:nth-child(3){ transform: translateY(-8px) rotate(-45deg); }

    /* SIDE MENU: turn into transform for smoother mobile */
    .side-menu{
      position:fixed;
      top:0;
      right:0;                     /* anchored right */
      transform:translateX(110%);  /* hidden off-canvas */
      width:320px;
      max-width:82%;
      height:100vh;
      background:var(--card);
      box-shadow:-6px 0 28px rgba(0,0,0,0.18);
      transition:transform .33s cubic-bezier(.2,.9,.2,1);
      z-index:1100;
      display:flex;
      flex-direction:column;
      will-change:transform;
      border-left:1px solid rgba(0,0,0,0.03);
    }
    .side-menu.open{ transform:translateX(0); }

    /* area for content that can scroll */
    .menu-content{
      padding:28px 20px;
      overflow-y:auto;
      flex:1;
      -webkit-overflow-scrolling:touch;
    }

    .menu-title{
      margin:0 0 12px 0;
      color:var(--navy);
      font-size:1.05rem;
      font-weight:700;
    }

    .side-menu .nav-link{
      display:block;
      margin:8px 0;
      padding:10px 8px;
      font-size:0.98rem;
      color:var(--muted);
      text-decoration:none;
      border-radius:6px;
    }
    .side-menu .nav-link:hover,
    .side-menu .nav-link:active{
      background:var(--bg2);
      color:var(--navy);
    }

    /* FIXED BOTTOM AREA inside menu (visible always) */
    .toggle-bar{
      padding:14px 18px;
      border-top:1px solid rgba(0,0,0,0.06);
      background:var(--card);
      box-shadow: 0 -6px 16px rgba(0,0,0,0.02) inset;
    }
    .theme-control{
      display:flex;
      justify-content:space-between;
      align-items:center;
      background:linear-gradient(90deg,rgba(28,214,206,0.03),rgba(41,52,98,0.01));
      padding:10px;
      border-radius:8px;
    }
    .theme-control .label{
      font-size:0.98rem;
      color:var(--muted);
    }
    .theme-control button{
      padding:8px 14px;
      border-radius:6px;
      border:1px solid rgba(0,0,0,0.12);
      background:transparent;
      cursor:pointer;
      font-size:0.95rem;
      color:var(--muted);
      white-space:nowrap;
    }

    /* OVERLAY */
    .overlay{
      position:fixed;
      top:0; left:0;
      width:100%; height:100%;
      background:rgba(0,0,0,0.32);
      opacity:0;
      pointer-events:none;
      transition:opacity .25s;
      z-index:1050;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    /* MAIN CONTENT */
    main{ max-width:1100px; margin:30px auto; padding:0 18px; }
    .card{ background:var(--card); border-radius:12px; padding:34px 42px; margin:26px 0; box-shadow:0 6px 20px var(--shadow); }
    h2{ color:var(--navy); border-bottom:3px solid var(--teal); padding-bottom:8px; margin:0 0 12px 0; }
    p{ line-height:1.6; color:var(--text); }
    pre,code{ background:var(--code-bg); border-left:4px solid var(--teal); padding:12px; border-radius:8px; display:block; color:var(--code-text); font-family:Consolas,monospace; }
    footer{ text-align:center; margin:40px 0; color:var(--muted); }

    /* small screens */
    @media(max-width:520px){
      header{ padding:34px 14px 54px; }
      header h1{ font-size:1.25rem; padding:0 8px; }
      .side-menu{ width:86%; }
      .theme-control button{ padding:8px 10px; font-size:0.92rem; }
    }

    /* Focus styles for accessibility */
    .hamburger:focus { outline: 3px solid rgba(28,214,206,0.2); border-radius:8px; }
    .side-menu a:focus, .theme-control button:focus { outline:3px solid rgba(28,214,206,0.18); outline-offset:2px; border-radius:6px; }

    /* prevent page shift when menu opens: we'll toggle .no-scroll on body via JS */
    body.no-scroll { overflow:hidden; touch-action:none; }
  </style>
</head>

<body>

  <!-- Overlay -->
  <div class="overlay" id="overlay" aria-hidden="true"></div>

  <!-- Header -->
  <header id="top">
    <h1>Modbus Protocol — Complete Tutorial & Reference</h1>

    <!-- hamburger with larger touch area -->
    <div class="hamburger" id="hamburger" role="button" aria-label="Open navigation" tabindex="0" aria-expanded="false" aria-controls="sideMenu">
      <div class="hamburger-inner" aria-hidden="true">
        <span></span><span></span><span></span>
      </div>
    </div>
  </header>

  <!-- SIDE MENU (off-canvas) -->
  <nav class="side-menu" id="sideMenu" aria-hidden="true" aria-label="Site menu">

    <!-- Scrollable region -->
    <div class="menu-content" id="menuContent">
      <div class="menu-title">Explore</div>

      <a href="index.html" class="nav-link">Home</a>

      <h4 style="margin-top:18px;color:var(--navy);font-weight:700;">Sections</h4>
      <a href="#overview" class="nav-link">Overview</a>
      <a href="#origins" class="nav-link">Origins & Why It Matters</a>
      <a href="#communication" class="nav-link">Communication Model</a>
      <a href="#physical" class="nav-link">Physical & Link Layers</a>
      <a href="#variants" class="nav-link">Variants — RTU, ASCII, TCP</a>
      <a href="#data" class="nav-link">Data Model — Coils & Registers</a>
      <a href="#function-codes" class="nav-link">Function Codes</a>
      <a href="#frames" class="nav-link">Frame Formats</a>
      <a href="#crc" class="nav-link">CRC-16 and LRC</a>
      <a href="#exceptions" class="nav-link">Exception Responses</a>
      <a href="#addressing" class="nav-link">Addressing & Register Mapping</a>
      <a href="#implementation" class="nav-link">Implementing Master & Slave</a>
      <a href="#testing" class="nav-link">Testing & Debugging</a>
      <a href="#security" class="nav-link">Security Considerations</a>
      <a href="#checklist" class="nav-link">Best Practices Checklist</a>
      <a href="#conclusion" class="nav-link">Conclusion</a>
      <div style="height:24px"></div> <!-- breathing space so content doesn't butt against bottom control -->
    </div>

    <!-- Fixed bottom bar (always visible) -->
    <div class="toggle-bar" role="region" aria-label="Theme control">
      <div class="theme-control">
        <div class="label">Dark mode</div>
        <button id="darkToggle" aria-pressed="false">Enable</button>
      </div>
    </div>
  </nav>

  <!-- Main content (full tutorial) -->
  <main>
    <section class="card" id="overview">
      <h2>Overview</h2>
      <p>Modbus is a simple application-layer messaging protocol originally designed for communication between PLCs and field devices. It defines how messages are structured and exchanged; it does not mandate a transport, which is why Modbus can run over serial (RTU/ASCII) and Ethernet (TCP).</p>
      <p>This guide is written as a reference you can rely on while building, debugging, or documenting Modbus-based systems.</p>
    </section>

    <section class="card" id="origins">
      <h2>Origins & Why It Matters</h2>
      <p>Designed for industrial control, Modbus became popular because it is:</p>
      <ul>
        <li>Open and simple — easy to implement on microcontrollers and PLCs.</li>
        <li>Interoperable — many vendors implemented it, reducing integration effort.</li>
        <li>Flexible — works across different physical layers and network types.</li>
      </ul>
      <p>Because of these properties Modbus is still widely used in factory automation, building management, energy metering, and gateway devices in IIoT architectures.</p>
    </section>

    <section class="card" id="communication">
      <h2>Communication Model</h2>
      <p>Modbus uses a <strong>request–response</strong> model: a master (client) sends requests; slaves (servers) reply. Classic RTU/ASCII slaves cannot initiate communication — the master must poll them. Modbus TCP uses client/server terminology but follows the same principle.</p>
      <p>Key operational rules:</p>
      <ul>
        <li>Only one master should control a serial bus to avoid collisions. On Ethernet you can have multiple clients connecting to a server, but typical SCADA setups centralize polling.</li>
        <li>Slaves are identified by a <strong>Unit ID</strong> (slave address) — low numbers are for devices, 0 often reserved for broadcast on RTU/ASCII.</li>
        <li>Timing matters on serial RTU — silent intervals (3.5 char times) delimit frames.</li>
      </ul>
    </section>

    <section class="card" id="physical">
      <h2>Physical & Link Layers (Practical Notes)</h2>
      <p>Common transports:</p>
      <ul>
        <li><strong>RS-485</strong> — differential pair, multi-drop capable, robust for industrial distances and noise. Usually half-duplex on a single pair.</li>
        <li><strong>RS-232</strong> — point-to-point (less common for multi-drop).</li>
        <li><strong>Ethernet (TCP/IP)</strong> — Modbus TCP runs over standard IP networks, convenient for gateways and SCADA.</li>
      </ul>
      <p>Practical wiring tips (RS-485): use a daisy-chain topology, termination resistors (typically 120Ω) at both ends, and biasing resistors to define idle state. Avoid star topologies and long unterminated stubs.</p>
    </section>

    <section class="card" id="variants">
      <h2>Variants — RTU, ASCII, TCP</h2>
      <h3>Modbus RTU</h3>
      <p>Binary encoding; compact frames; CRC-16 for integrity. Widely used in field devices where bandwidth is limited.</p>
      <h3>Modbus ASCII</h3>
      <p>Each byte encoded as two ASCII characters. Easier to debug with terminals but less efficient. Uses LRC for integrity.</p>
      <h3>Modbus TCP</h3>
      <p>Runs Modbus PDUs inside TCP packets. Adds a 7-byte MBAP header (Transaction ID, Protocol ID, Length, Unit ID). TCP provides error detection and reassembly, so CRC/LRC are omitted.</p>
    </section>

    <section class="card" id="data">
      <h2>Data Model — Coils & Registers</h2>
      <p>Modbus presents four logical data areas that devices expose:</p>
      <ul>
        <li><strong>Coils (0xxxx)</strong> — discrete read/write bits (outputs).</li>
        <li><strong>Discrete Inputs (1xxxx)</strong> — discrete read-only bits (inputs).</li>
        <li><strong>Input Registers (3xxxx)</strong> — read-only 16-bit words (sensor values).</li>
        <li><strong>Holding Registers (4xxxx)</strong> — read/write 16-bit words (setpoints, configs).</li>
      </ul>
      <p>Devices and vendor docs often present human-friendly 1-based addresses (e.g., 40001). Protocol requests use zero-based offsets. Always document mapping and scale factors (e.g., value/10 for temperature).</p>
    </section>

    <section class="card" id="function-codes">
      <h2>Function Codes — What You Need to Know</h2>
      <p>Function codes (one byte) tell the slave what operation to perform. The most-used codes are below.</p>
      <table>
        <thead><tr><th>Code</th><th>Name</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td>01 (0x01)</td><td>Read Coils</td><td>Read status of coils (bits)</td></tr>
          <tr><td>02 (0x02)</td><td>Read Discrete Inputs</td><td>Read discrete input bits</td></tr>
          <tr><td>03 (0x03)</td><td>Read Holding Registers</td><td>Read block of 16-bit registers</td></tr>
          <tr><td>04 (0x04)</td><td>Read Input Registers</td><td>Read input registers (read-only)</td></tr>
          <tr><td>05 (0x05)</td><td>Write Single Coil</td><td>Write a single output bit</td></tr>
          <tr><td>06 (0x06)</td><td>Write Single Register</td><td>Write a single 16-bit register</td></tr>
          <tr><td>15 (0x0F)</td><td>Write Multiple Coils</td><td>Write multiple bits</td></tr>
          <tr><td>16 (0x10)</td><td>Write Multiple Registers</td><td>Write multiple 16-bit registers</td></tr>
        </tbody>
      </table>
      <p>There are additional function codes for file record access, diagnostics, masks, and more; consult the official Modbus Application Protocol documentation for edge cases.</p>
    </section>

    <section class="card" id="frames">
      <h2>Frame Formats — Byte-Level Examples</h2>
      <h3>RTU frame (serial)</h3>
      <p>Structure: <kbd>Slave ID (1)</kbd> + <kbd>Function (1)</kbd> + <kbd>Data (N)</kbd> + <kbd>CRC (2)</kbd></p>
      <pre><code>Example (hex): 03 03 00 64 00 02 85 C9
// Slave 3, Function 3 (read holding), start 0x0064 (100), qty 2, CRC=85C9</code></pre>

      <h3>ASCII frame</h3>
      <pre><code>Example: :030300640002A5&lt;CR&gt;&lt;LF&gt;  (LRC used)</code></pre>

      <h3>Modbus TCP (MBAP + PDU)</h3>
      <pre><code>MBAP: [TransID(2)][ProtID(2)=0][Length(2)][UnitID(1)]
PDU: [Function][Data...]

Example (hex): 00 01 00 00 00 06 03 03 00 64 00 02</code></pre>
      <div class="note">MBAP Transaction ID lets a TCP client send multiple outstanding requests; responses are correlated via that ID.</div>
    </section>

    <section class="card" id="crc">
      <h2>CRC-16 and LRC — Integrity Checks</h2>
      <h3>CRC-16 (RTU)</h3>
      <p>RTU uses CRC-16 (polynomial 0xA001). The CRC covers address, function, and data fields and is appended low byte first. Use tested library routines or lookup-table implementations for speed and correctness.</p>
      <pre><code>// Simplified CRC pseudocode
uint16_t crc = 0xFFFF;
for each byte b in message:
  crc ^= b;
  for i from 0..7:
    if crc & 0x0001:
      crc = (crc >> 1) ^ 0xA001;
    else:
      crc >>= 1;
append CRC low, CRC high</code></pre>

      <h3>LRC (ASCII)</h3>
      <p>ASCII frames use an LRC (one byte), which is the two's complement of the sum of data bytes. Again, use library functions.</p>
    </section>

    <section class="card" id="exceptions">
      <h2>Exception Responses</h2>
      <p>If a slave cannot fulfill a request it responds with the function code ORed with 0x80 and an exception code byte.</p>
      <table>
        <thead><tr><th>Code</th><th>Meaning</th></tr></thead>
        <tbody>
          <tr><td>01</td><td>Illegal Function</td></tr>
          <tr><td>02</td><td>Illegal Data Address</td></tr>
          <tr><td>03</td><td>Illegal Data Value</td></tr>
          <tr><td>04</td><td>Slave Device Failure</td></tr>
          <tr><td>05</td><td>Acknowledge (long op)</td></tr>
          <tr><td>06</td><td>Slave Device Busy</td></tr>
          <tr><td>0A (10)</td><td>Gateway Path Unavailable</td></tr>
        </tbody>
      </table>
      <p>On receiving exceptions the master should log them and implement retry/backoff; persistent exceptions require investigation of device configuration, addressing, and register mapping.</p>
    </section>

    <section class="card" id="addressing">
      <h2>Addressing & Register Mapping — Practical Advice</h2>
      <p>Common pitfalls: off-by-one addressing, scale/endianness confusion, and undocumented register conventions. Always provide a clear register map in device documentation with:</p>
      <ul>
        <li>Register number (human-friendly), protocol offset (zero-based)</li>
        <li>Data type (uint16, int16, uint32, float32)</li>
        <li>Scale factor and units (e.g., value/10 == °C)</li>
        <li>Read/Write permissions and valid ranges</li>
      </ul>
      <pre><code>Example device map:
40001 (offset 0) : Holding Reg : Temperature setpoint : int16 : value/10 -> °C
40002 (offset 1) : Holding Reg : Control mode (0:auto,1:manual) : uint16</code></pre>
    </section>

    <section class="card" id="implementation">
      <h2>Implementing Master & Slave — Patterns</h2>
      <p>Use stable libraries wherever possible. High-level implementation notes:</p>
      <ul>
        <li>Master: construct request, send, wait for response (timeout), validate CRC/MBAP, parse data, handle exceptions.</li>
        <li>Slave: listen for frames, validate CRC/Unit ID, execute function, return response or exception (or ignore frames not for your Unit ID).</li>
        <li>RS-485 transceivers: manage driver-enable (DE) and receiver-enable (RE) pins to avoid bus contention; only drive the bus when transmitting.</li>
      </ul>
      <pre><code>// Master pseudocode
send_frame(request);
if receive(response, timeout):
  if valid_crc(response):
    if response.is_exception():
      handle_exception();
    else:
      process(response);
  else:
    log_crc_error();
else:
  handle_timeout();</code></pre>
    </section>

    <section class="card" id="testing">
      <h2>Testing & Debugging</h2>
      <ul>
        <li>Use a USB↔RS485 adapter and a terminal/sniffer to capture RTU frames for debugging.</li>
        <li>Tools: Modbus Poll, QModMaster, Modbus Doctor for Windows; Wireshark for Modbus TCP analysis.</li>
        <li>Compare raw hex frames from a known-working device to your device to spot differences in addressing, byte order, or CRC.</li>
      </ul>
      <div class="note">If your device replies with malformed frames, check baud/parity/stop settings first — mismatched serial parameters are the most common cause of CRC errors.</div>
    </section>

    <section class="card" id="security">
      <h2>Security Considerations</h2>
      <p>Modbus (RTU/ASCII/TCP) provides no native encryption or authentication. For production systems adopt layered defenses:</p>
      <ul>
        <li>Network segmentation (VLANs) and firewalls to restrict access to control networks.</li>
        <li>Use secure gateways that authenticate clients and translate to internal Modbus networks.</li>
        <li>Prefer encrypted transports (MQTT+TLS, OPC-UA) for cloud integrations; keep Modbus inside trusted perimeter and monitor logs.</li>
      </ul>
    </section>

    <section class="card" id="checklist">
      <h2>Best Practices Checklist</h2>
      <ul>
        <li>Create and publish a clear register map for every device.</li>
        <li>Reserve unique slave IDs and avoid collisions.</li>
        <li>Use termination and biasing on RS-485; prefer daisy-chain wiring.</li>
        <li>Implement conservative timeouts, retries, and logging of exceptions & CRC failures.</li>
        <li>Use tested libraries and do not roll your own CRC unless necessary.</li>
      </ul>
    </section>

    <section class="card" id="conclusion">
      <h2>Conclusion</h2>
      <p>Modbus remains one of the most enduring and practical communication protocols in industrial automation. Its simplicity, wide adoption, and hardware independence have made it a foundational standard for decades. From its early RS-485 serial roots to modern Modbus TCP implementations, it continues to provide a reliable bridge between sensors, controllers, and SCADA systems. Whether you're designing embedded firmware or integrating legacy systems, understanding Modbus deeply equips you to build robust, interoperable, and scalable industrial solutions.</p>
    </section>
  </main>

  <footer>© 2025 All Rights Reserved</footer>

  <script>
    // Elements
    const hamburger = document.getElementById('hamburger');
    const sideMenu = document.getElementById('sideMenu');
    const overlay = document.getElementById('overlay');
    const darkBtn = document.getElementById('darkToggle');
    const navLinks = document.querySelectorAll('.nav-link');
    const body = document.body;

    // Open menu: add classes, lock body scroll for mobile
    function openMenu() {
      sideMenu.classList.add('open');
      overlay.classList.add('show');
      sideMenu.setAttribute('aria-hidden', 'false');
      hamburger.setAttribute('aria-expanded', 'true');
      overlay.setAttribute('aria-hidden', 'false');
      body.classList.add('no-scroll');
      // Move focus into the menu for accessibility
      // find first focusable link
      const firstLink = sideMenu.querySelector('.nav-link');
      if (firstLink) firstLink.focus();
    }

    // Close menu
    function closeMenu() {
      sideMenu.classList.remove('open');
      overlay.classList.remove('show');
      sideMenu.setAttribute('aria-hidden', 'true');
      hamburger.setAttribute('aria-expanded', 'false');
      overlay.setAttribute('aria-hidden', 'true');
      body.classList.remove('no-scroll');
      hamburger.focus(); // return focus to toggle
    }

    // Toggle menu (works on click, touch, pointer)
    function toggleMenu(e) {
      // prevent double-handling of touch+click
      if (sideMenu.classList.contains('open')) closeMenu();
      else openMenu();
    }

  function addToggleListeners(el) {
  // pointerup is safest for mobile
  el.addEventListener('pointerup', function () {
      toggleMenu();
  });

  // keyboard support
  el.addEventListener('keydown', function (e) {
      if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleMenu();
      }
  });
}


    addToggleListeners(hamburger);

    // overlay closes menu
    overlay.addEventListener('pointerdown', function (e) {
      e.preventDefault();
      closeMenu();
    });

    // Close when any nav link clicked (auto-close)
    navLinks.forEach(link => {
      link.addEventListener('click', () => {
        // small timeout to allow anchor jump on same page
        setTimeout(closeMenu, 120);
      });
    });

    // Close with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && sideMenu.classList.contains('open')) {
        closeMenu();
      }
    });

    // Simple persistent dark-mode toggle inside the menu bottom bar
    (function() {
      if (!darkBtn) return;
      let dark = localStorage.getItem('modbus-dark') === 'true';

      function applyTheme(isDark){
        if (isDark){
          document.documentElement.style.setProperty('--bg1','#050505');
          document.documentElement.style.setProperty('--bg2','#0a0a0a');
          document.documentElement.style.setProperty('--card','#0b0d10');
          document.documentElement.style.setProperty('--navy','#d8f7ff');
          document.documentElement.style.setProperty('--muted','#bcd8d8');
          document.documentElement.style.setProperty('--text','#f6fbfb');
          document.documentElement.style.setProperty('--code-bg','#071016');
          document.documentElement.style.setProperty('--code-text','#e8fbfb');
          document.documentElement.style.setProperty('--teal','#1cd6ce');
          document.documentElement.style.setProperty('--header-grad','linear-gradient(90deg,#071426,#03202a)');
          document.documentElement.style.setProperty('--header-text','#d6f9ff');
          darkBtn.textContent = 'Disable';
          darkBtn.setAttribute('aria-pressed','true');
        } else {
          document.documentElement.style.setProperty('--bg1','#f8fbfd');
          document.documentElement.style.setProperty('--bg2','#e9f5f7');
          document.documentElement.style.setProperty('--card','#ffffff');
          document.documentElement.style.setProperty('--navy','#293462');
          document.documentElement.style.setProperty('--muted','#0e4d66');
          document.documentElement.style.setProperty('--text','#122');
          document.documentElement.style.setProperty('--code-bg','#f4fbfd');
          document.documentElement.style.setProperty('--code-text','#073');
          document.documentElement.style.setProperty('--teal','#1cd6ce');
          document.documentElement.style.setProperty('--header-grad','linear-gradient(90deg,#b3ecff,#a8fff0,#d9ffff)');
          document.documentElement.style.setProperty('--header-text','#083c5d');
          darkBtn.textContent = 'Enable';
          darkBtn.setAttribute('aria-pressed','false');
        }
        // update hamburger bars color
        const spans = document.querySelectorAll('.hamburger-inner span');
        spans.forEach(s => {
          s.style.background = getComputedStyle(document.documentElement).getPropertyValue('--header-text').trim() || '#083c5d';
        });
        // update pre/code colors
        document.querySelectorAll('pre, code').forEach(el => {
          el.style.background = getComputedStyle(document.documentElement).getPropertyValue('--code-bg');
          el.style.color = getComputedStyle(document.documentElement).getPropertyValue('--code-text');
        });
      }

      // initialize
      applyTheme(dark);

      // make button easy to tap
      darkBtn.addEventListener('pointerdown', function(e){
        e.preventDefault();
        dark = !dark;
        localStorage.setItem('modbus-dark', dark.toString());
        applyTheme(dark);
      });

      // keyboard support
      darkBtn.addEventListener('keydown', function(e){
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          dark = !dark;
          localStorage.setItem('modbus-dark', dark.toString());
          applyTheme(dark);
        }
      });
    })();

    // Ensure the fixed bottom toggle is visible: focusable & accessible
    // Already placed in .toggle-bar so it stays visible even on small screens.
    // No extra code required here.

    // Optional: prevent accidental touches inside menu-content from closing menu (handled)
  </script>
</body>
</html>
